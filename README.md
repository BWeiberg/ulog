# µlog (micro logger)

µlog is a log toolchain which is especially designed for embedded C/C++ projects where a convenient and extensive logging facility should be implemented, 
but there are some limitations due to:

+ small code memory (ROM) available
+ small bandwidth on the interface used to transfer the log data
+ poor processing performance of the CPU

Imagine a server program, for example, that runs on an embedded device, and you may like to have detailed logs concerning incoming connection requests or 
if something within the socket API fails. In this case, a log message may look like this:

```
Info: Got new incoming connection request from 192.168.1.100 port 54312 to port 8080
```

In C, you may implement this message more or less like this:

```c
...
ushort my_port = htons(8080);
struct sockaddr_in from;
...
printf(
    "Info: Got new incoming connection from %s port %u to port %u.\n", 
    inet_ntoa(from.sin_addr), from.sin_port, ntohs(my_port)
);
...
```

For such a detailed log message, the amount of memory needed in ROM is quite high, because the whole string `"Info: Got new incoming ..."` has to be 
stored somewhere. The whole log message has a size of 85 bytes (including a termination character) that need to be transmitted to the outside world. 
Also, the computing power needed to process the C-Library call to `printf()` has to be taken into account.

The same message in µlog can be significantly reduced in size, so that only a small header and the variables within the message string have to be 
transmitted. In this example, the message size melts down to only 14 bytes (6 bytes header + 4 bytes from.sin_addr + 2 bytes from.sin_port + 2 bytes my_port). 
And the computing power for parsing the arguments given to `printf()` of the C-Library will be reduced to only some `memcpy()` calls.

## How does µlog work?

Instead of placing the extensive log message in the form of a string constant directly into your code, you would write the whole text section as a 
comment just before a call to `ulog()`, where you only pass the variables to the logger.

Just before running your compiler, a parser called `make_catalogue` has to be executed. This parser searches for all occurrences of `ulog()`, 
generates a unique log ID for those calls, and builds a log message catalog with the content you have written within the corresponding comment 
just before the call to `ulog()`.

Your embedded target will now send log messages to a host system in a very compressed form, which takes much less code size, computing power, 
and bandwidth. On the host side, the generated catalog of your application is parsed against the received log message, the format string is 
extracted, and the variables transferred via the target connection are inserted into the log message.

C-Code example on the embedded device:

```c
...
char temp[8];
memcpy(&temp[0], from.sin_addr, sizeof(from.sin_addr));
memcpy(&temp[4], from.sin_port, sizeof(from.sin_port));
memcpy(&temp[6], ntohs(my_port), sizeof(my_port));

/*!
 Info: Got new incoming connection from %s[ipv4] 
 port %u[num] to port %u[num]
*/
ulog(0, temp, sizeof(temp));
```

After running `make_catalogue`, the statement `ulog(0, temp, sizeof(temp));` will be modified with a unique log ID (e.g., `ulog(123456, temp, sizeof(temp));`), 
and the catalog file will be generated like this:

```
================================================================================
# 123456 
@ 890a843927146f29050f4a539c60f78f8fed4d7d1cded5af2d596605e1cdbb06 2025-01-20 15:40:54 server.c >

   Info: Got new incoming connection from %s[ipv4]
   port %u[num] to port %u[num]
   
--------------------------------------------------------------------------------
```
The key benefit of µlog is that it moves the computing power needed to process log messages from the embedded system to the host system, 
which is typically much more powerful. This is achieved by:

- Instead of storing the full log message strings in the embedded system's ROM, only a compact header and variable data is transmitted.
- On the host side, a catalog generated by the `make_catalogue` tool is used to reconstruct the full log message from the compact data received from the embedded system.

This approach significantly reduces the code size, bandwidth requirements, and processing load on the embedded system, making it well-suited for resource-constrained environments. 
The trade-off is that the host system now needs to perform the log message reconstruction, but this is typically not a problem given the higher processing power available on the host.
